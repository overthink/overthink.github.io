---
layout: post
title: All About Polymorphism
---

While working on [something else](#derp) I became aware that I didn't really know anything about polymorphism.  I couldn't, for example, produce answers to these quesitons:

* What is ad-hoc polymorphism?
* If ad-hoc polymorphism is a thing, then what is plain ol' polymorphism?
* What is a polymorphic function vs. a polymorphic type?
* What is compile-time polymorphism vs. runtime polymorphism?

To me, polymorphism meant implementing interfaces and overriding methods in derived classes, but that's vague,object oriented specific, and insufficient for the questions above.  So I Googled, checked Wikipedia and Stack Overflow, and the result was a bunch of unsatisfying and sometimes-conflicting definitions.  I decided to look a little deeper and this article is the result.

My goal is to clearly describe polymorphism in a language-agnostitc manner, but provide examples in various languages to make it concrete.  For context, my background is primarly object-oriented languages like Java, Scala, and Python, but I'm lang-curious and am looking at this from a Clojure and Haskell perspective too.

## Poly Polymorphism

The first thing to know is that there are many varieties of polymorphism.  Here's a nifty chart lifted from [this fine paper][1] by Cardelli and Wegner that shows the main varieties and how they're related:

![Varieties of polymorphism](/img/varieties-of-polymorphism.png "Varieties of polymorphism")

Some definitions:

Polymorphism
: Values and variables may have more than one type.

This definition is from the Cardelli paper as well.  _Values_ as used here includes function values, so keep that in mind.

Ad-hoc polymorphism
: Values can take on a finite set of types that may have no structure in common.  e.g. a function could be written to accept arguments of type `String`, or `Boolean`, or `Map[Foo, Bar]`, but nothing else.  Key to note here is that **different code may execute depending on the type of the arguments**.

Universal polymorphism
: Values can take on an infinite number of types that share some common structure.  e.g. in Java the "shared structure" might be specified as an interface or base class.  This is _true_ polymorphism since -- unlike ad-hoc polymorphism -- **the same code executes for arguments of any allowed type**.

Now, for the leaves on this tree... If you're working with an object oriented language like Java, C#, or even Python or Ruby, then odds are that people are talking about _inclusion polymorphism_ when they just say _polymorphism_.  So I'll start there.



## Polymorphism Defined (a few times)

The short definition of polymorphism that I like best comes from [an answer on Stack Overflow][3]: **Polymorphism means reuse with different types**.  My interpretation of this is that you can call a "single" logical function with arguments of different types and it will work, possibly exhibiting different behaviours depending on the types given.

Other short definitions I found helpful:

* Wikipedia says that [polymorphism][2] is a programming language feature that **allows values of different data types to be handled using a uniform interface**.
* The paper mentioned above says that in a polymorphic language **some values and variables may have more than one type**.

These are good high-level definitions, but to get to concrete examples we must acknowledge that there are different varieties of polymorphism.  Here's a nifty chart lifted from the paper:

![Varieties of polymorphism](/img/varieties-of-polymorphism.png "Varieties of polymorphism")

Ad-hoc polymorphism
: Functions can be written to work on a finite set of types that may have no structure in common.  e.g. a function could be written to accept arguments of type `String`, or `Boolean`, or `Map[String, Long]`, but nothing else.  Key to note here is that **different code may execute depending on the type of the arguments**.

Universal polymorphism
: Functions can be written to work on an infinite number of types that share some common structure.  e.g. in Java the "shared structure" might be specified as an interface or base class.  This is _true_ polymorphism since -- unlike ad-hoc polymorphism -- **the same code executes for arguments of any allowed type**.

Now, for the leaves on this tree... If you're working with an object oriented language like Java, C#, or even Python or Ruby, then odds are that people are talking about _inclusion polymorphism_ when they just say _polymorphism_.  So I'll start there.

### Inclusion Polymorphism

My understanding is that the word _inclusion_ here takes its meaning from [set theory][7], and basically means _subset_.  A is an inclusion of B if A is a subset of B.  Here's an image stolen from Wikipedia to illustrate this difficult concept:

![Inclusion == subset for our purposes](/img/inclusion.png)

If you think of our sets A and B as sets of properties that form a type, then you can see where this is going: inclusion polymorphism is just the familiar case of subtyping: B extends A.  Objects of a subtype can be manipulated as if they were objects of their supertype.  Let's look at the canonical example:

{% highlight scala %}
trait Animal {
  def makeNoise()
}
class Cat extends Animal {
  def sitOnKeyboard() { ... }
  def makeNoise() { println("Meow") }
}
class Dog extends Animal {
  def fetchBone() { ... }
  def makeNoise() { println("Woof") }
}

val a1: Animal = new Cat
val a2: Animal = new Dog
noiseMaker(a1) // 'Meow'
noiseMaker(a2) // 'Woof'
{% endhighlight %}

In this example `noiseMaker()` is a polymorphic function since 

1. it works unchanged when applied to any subtype of `Animal`, and
1. you can get different behaviour depending on the type of `Animal` provided.

### Parametric Polymorphism

In parametric polymorphism a function has one or more type parameters.  The parameter is bound at the time of function application.  Here's an example in Java:

{% highlight java %}
import java.util.List;
import java.util.ArrayList;

class Test {
  public static <T> T head(List<T> xs) {
    return xs.get(0);
  }
  public static void main(String[] args) {
    final List<String> xs = new ArrayList<String>() { { add("A"); add("B"); add("C"); } };
    final List<Integer> ys = new ArrayList<Integer>() { { add(1); add(2); add(3); } };
    System.out.println(head(xs)); // "A"
    System.out.println(head(ys)); // "1"
  }
}
{% endhighlight %}

The generic function `head` here has type parameter `T` and is an example of parametric polymorphism.  In this case the type doesn't matter at all since the function is written entirely in terms of the container type `List`.  You write the function `head` once, and reuse it with different types.

Here's another example of parametric polymorphism, this time in Haskell which is easier on the eyes:

{% highlight haskell %}
rev :: [a] -> [a]
rev [] = []
rev (x:xs) = rev xs ++ [x]

main :: IO ()
main = do putStrLn $ show $ rev ["A", "B", "C"] -- ["C","B","A"]
          putStrLn $ show $ rev [1, 2, 3]       -- [3,2,1]
{% endhighlight %}

Function `rev` is a generic function that will reverse any list.  This time the type parameter is `a`, and once again it doesn't matter what `a` ends up being when the function is applied.

### Overloading

Overloading is a form of ad-hoc polymorphism.  Previously, it never occurred to me that overloading had anything to do with polymorphism, but given the definitions above, it obviously does:

{% highlight scala %}
class Serializer {
  def toJson(x: String): String = "\"" + x + "\""  // yes, naive
  def toJson(x: Int): String = x.toString
}
{% endhighlight %}

Here we've provided two implementations of `toJson` that accept different, **unrelated** types as arguments (`String` and `Int`) and there's no shared code in the two implementations.  This is exactly our definition of ad-hoc polymorphism above.

This was a bit anti-climactic for me.  I'd primarily seen _ad-hoc_ used when talking about typeclasses and protocols, and I assumed there'd be more to the concept.  The key realization for me was that **typeclasses and protocols are really just structured overloading**. They allow you to add an additional implementation of some existing function, but with different argument types, and the compiler or runtime yells at you out if you try to use said function in the wrong way.

Continuing a bit with the JSON serializer example, let's say we need to serialize `Boolean`s as well as `String`s and `Int`s, but we don't have access to the source code of `Serializer`.  In an object oriented language we might do this:

{% highlight scala %}
class MySerializer extends Serializer {
  def toJson(x: Boolean): String = x.toString
}
{% endhighlight %}

Now our `Serializer` instance can serialize three types through a single logical `toJson` method.  Note that all we've done here is provide a new implementation of an exisitng named function.  We also had to use inheritance to do it, which muddies the water a bit, but I'll save editorial comments for another time.

If you wanted to do the same thing in Haskell you might use a typeclass.

{% highlight haskell %}
{-# LANGUAGE TypeSynonymInstances #-}

class Json a where
  toJson :: a -> String

instance Json String where
  toJson x  = "\"" ++ x ++ "\""

instance Json Int where
  toJson x  = show x

instance Json Bool where
  toJson True  = "true"
  toJson False = "false"

main :: IO ()
main = do putStrLn $ toJson "Hi there"
          putStrLn $ toJson 42
          putStrLn $ toJson false

{% endhighlight %}

This gives us a polymorphic function `toJson` that works with `String`, `Int`, and `Bool`.  Again we've just provided multiple implementations of the same named function and the correct implementation is chosen based on the argument type -- i.e. it's just overloading.

For fun, here it is with a Clojure protocol:

{% highlight clojure %}
(defprotocol Json
  (to-json [x] "Serialize x to a JSON string"))

(extend String
  Json
  {:to-json (fn [x] (str "\"" x "\""))})

(extend Integer
  Json
  {:to-json (fn [x] (str x))})

(extend Boolean
  Json
  {:to-json (fn [x] (str x))})

(println (to-json "Hi there"))
(println (to-json 42))
(println (to-json false))
{% endhighlight %}

The protocol is just a mechanism for overloading the function `to-json`.  You could also do this as a Clojure multimethod, but we'll leave that for now.

### Coercion

I didn't really want to cover coercion, but I feel obligated since I've talked about everything else.  With coercion, a function doesn't have to be written to work with different types, but instead, when applied the system automatically converts the arguments to the types required by the function.

This is considered ad-hoc polymorphism becuase each coercion has to be explicitly handled with custom code.

A silly Javascript example from [here][8]:

{% highlight javascript %}
7 + 7 + 7; // = 21  
7 + 7 + "7"; // = 147  
"7" + 7 + 7; // = 777  
{% endhighlight %}

The `+` function does numeric addition until it encounters a string argument, at which point it converts (coerces) the other argument to string and starts doing string concatenation.

More common examples from Java:

{% highlight java %}
(1 + 4) / 2   // 2 -- everything is an int
(1 + 4) / 2.0 // 2.5
double x = 5; // works, despite 5 reading as an int
{% endhighlight %}

In the second line the divisor is a double, so the dividend is coerced to a double before the division is done.  The assignment operation for variable `x` also works, despite the right side parsing as an integer.  Java coerces 5 to a double before assigning.

Scala is an interesting case here because it supports user-created [implicit conversions][9].  These could be used to coerce arguments before a function is applied.  I'll leave further investigation as an exercise for the reader.

## Polymorphic Functions vs. Types

I'm still confused on this topic.

Polymorphic function
: A function that accepts arguments of more than one type.  There are many types of polymorphic function.  See the rest of this article for examples.

Polymorphic type
: ???

I've read a number of insonsistent or confusing definitons of polymoprhic type:

* A type whose operations are applicable to values of more than one type (what are _operations_ in this context)
* A type that can be used with a polymorphic function (herp derp)
* A C++ class with at least one virtual method (or a Java class with at least one non-final method)

If you can set me straight on this, please let me know.

## Compile-time vs. runtime Polymorphism

## Summary

## Conclusion


[1]: http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf "On Understanding Types, Data Abstraction, and Polymorphism, Cardelli and Wegner, 1985"
[2]: http://en.wikipedia.org/wiki/Polymorphism_(computer_science) "Polymorphism at Wikipedia"
[3]: http://stackoverflow.com/a/367396 "What is the difference between Abstraction and Polymorphism"
[4]: http://stackoverflow.com/a/6885445 "Parametric polymorphism vs ad-hoc polymorphism"
[5]: http://stackoverflow.com/questions/5854581/polymorphism-in-c/5854862#5854862 "Polymorphism in C++"
[6]: http://www.haskell.org/tutorial/classes.html "Haskell tutorial on type classes"
[7]: http://en.wikipedia.org/wiki/Inclusion_(set_theory)
[8]: http://blog.jeremymartin.name/2008/03/understanding-loose-typing-in.html "Weak typing in Javascript"
[9]: http://www.codecommit.com/blog/ruby/implicit-conversions-more-powerful-than-dynamic-typing "Scala implicit conversion"

http://www.itu.dk/courses/BPRD/E2009/fundamental-1967.pdf "Fundamental Concepts in Programming Languages, Strachey, 1967"
http://www.tfeng.me/papers/milner78theory.pdf "A Theory of Type Polymorphism in Programming, Milner, 1978"

## Answers to Everything

Most of this article is based on this [fine paper on understanding polymorphism][1] (pdf).  By all means skip my article and just read section 1.3 of the paper!  Or stay tuned since I'll throw in some code examples and filter some of the details.  The entire first section of the paper is very accessible, but sections two and beyond are perhaps... not for everyone.

## Confusion With Other Things

I found that a lot of online discussion seemed to equate the following terms with polymorphism:

* dynamic dispatch
* interface and implementation inheritance
* data abstraction

These concepts _are_ related to polymorphism 

